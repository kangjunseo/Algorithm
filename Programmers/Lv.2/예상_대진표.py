def solution(n,a,b): return len(format((a-1)^(b-1),'b'))

# 핵심 아이디어 : 비트 연산자 '^'를 사용 >> XOR 연산
#
#### 예시 케이스를 활용한 설명 ####
#
# a : 4, b : 7 일 때, answer = 3
#
# a - 1 = 3 >> 이진수로 변환 >> 011
# b - 1 = 6 >> 이진수로 변환 >> 110
# XOR 연산 결과는 101 으로 길이는 3이다.
#
#
#### 다른 케이스를 활용한 추가 설명 ####
# 
# a : 8, b : 7 일 때, answer = 1
#
# a - 1 = 7 >> 이진수로 변환 >> 111
# b - 1 = 6 >> 이진수로 변환 >> 110
# XOR 연산 결과는 1로 길이는 1이다. 
#
#
#### XOR로 비트의 길이로 풀이가 가능한 이유 ####
#
# 토너먼트 구조 상 큰 트리의 절반을 기준으로 다른 경계에 있다면, 그 시점에서의 남은 트리의 크기 만큼
# 경기 수가 증가하게 된다. 가장 쉬운 예시로 1번과 2번은 바로 붙게 되는데, 다른 경계에 위치하기 위한
# 트리의 최대 크기가 2의 1승 이기 때문에 바로 붙게 되는 것이다.
#
# 현재 인덱싱이 1 based 인덱싱이므로 a와 b에 각각 1을 빼서 0 based 인덱싱으로 변환한 후, 비트
# 연산인 XOR (파이썬 코드로는 ^로 연산)을 바로 적용하면, 서로 다른 경계에 있을 때 비트가 켜지게 된다.
# (XOR 연산의 경우 해당 비트에서 값이 다를 때 비트가 켜지기 때문) 
# 가장 처음으로 켜진 비트 (트리가 가장 클 때 켜진 비트)가 가장 왼쪽의 비트일 것이고, 2진수는 통상적으로
# 가장 왼쪽의 0들을 무시하고 표현하므로, 2진수의 길이가 곧 이 문제의 해답이 될 것이다.
#
